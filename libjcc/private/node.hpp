#ifndef _JCC_NODE_HPP_
#define _JCC_NODE_HPP_

#include <string>
#include <vector>
#include <memory>
#include <map>
#include <stack>
#include <queue>
#include <mutex>
#include <functional>
#include <algorithm>
#include <random>

namespace jcc
{
    template <typename T>
    class Node
    {
    public:
        ///=================================================================
        /// Constructors & Destructors
        ///=================================================================

        /// @brief Construct a new Node object
        Node()
        {
            this->m_name = autogenerate_name();
            this->m_value = T();
            this->m_children = std::vector<std::shared_ptr<Node>>();
            this->m_children_named = std::map<std::string, std::shared_ptr<Node>>();
        }

        /// @brief Construct a new Node object
        /// @param value T of the node
        /// @param name Name must be unique or is automatically generated
        /// @param children Children of the node
        Node(T value, const std::string &name = "", const std::vector<Node> &children = {})
        {
            if (name.empty())
            {
                this->m_name = autogenerate_name();
            }
            else
            {
                this->m_name = name;
            }

            this->m_value = value;
            this->m_children = std::vector<std::shared_ptr<Node>>();
            this->m_children_named = std::map<std::string, std::shared_ptr<Node>>();
            this->add_children(children);
        }

        Node(const Node &other)
        {
            this->m_name = other.m_name;
            this->m_value = other.m_value;
            this->m_children = other.m_children;
            this->m_children_named = other.m_children_named;
        }

        /// @brief Destroy the Node object
        ~Node()
        {
            this->erase_children();
        }

        ///=================================================================
        /// Getters & Setters
        ///=================================================================

        /// @brief Get const T reference
        /// @return T
        const T &value() const { return this->m_value; }

        /// @brief Get writable T reference
        /// @return T
        T &value() { return this->m_value; }

        /// @brief Get const Name reference
        /// @return std::string
        const std::string &name() const { return this->m_name; }

        /// @brief Get writable Name reference
        /// @return std::string
        std::string &name() { return this->m_name; }

        /// @brief Get the Children
        /// @return std::vector<Node>
        const std::vector<std::shared_ptr<Node>> &children() const { return this->m_children; }

        /// @brief Get writable Children reference
        /// @return std::vector<Node>
        std::vector<std::shared_ptr<Node>> &children() { return this->m_children; }

        /// @brief Set the Children
        /// @param children The children
        void children(const std::vector<Node> &children) { this->m_children = children; }

        ///=================================================================
        /// Manage children
        ///=================================================================

        /// @brief Add a child
        /// @param child The child to add
        /// @param newname. Unique name of the child. If empty, name is autogenerated
        void add_child(const Node &child, const std::string &newname = "")
        {
            auto us = std::make_shared<Node>(*this);
            auto new_child = std::make_shared<Node>(child);

            if (newname.empty() && child.m_name.empty())
            {
                std::string n = autogenerate_name();
                new_child->m_name = n;
                this->m_children_named[n] = new_child;
            }
            else if (!newname.empty())
            {
                this->m_children_named[newname] = new_child;
            }
            else
            {
                this->m_children_named[child.m_name] = new_child;
            }

            this->m_children.push_back(new_child);
        }

        /// @brief Add children
        /// @param children The children to add
        void add_children(const std::vector<Node> &children)
        {
            for (const auto &child : children)
            {
                this->add_child(child);
            }
        }

        /// @brief Remove a child by name.
        /// @param name The unique name of the child
        /// @return true if the child was removed. false if doesn't exist
        bool remove_child(const std::string &name)
        {
            std::stack<Node *> node_stack;
            node_stack.push(this); // Start with the current node

            while (!node_stack.empty())
            {
                Node *current = node_stack.top();
                node_stack.pop();

                if (current->m_name == name)
                {
                    this->m_children_named.erase(name);
                    this->m_children.erase(std::find_if(this->m_children.begin(), this->m_children.end(), [&](const std::shared_ptr<Node> &node)
                                                        { return node->m_name == name; }));

                    return true;
                }

                for (const auto &child : current->m_children)
                {
                    node_stack.push(child.get()); // Add children to the stack to visit later
                }
            }

            return false;
        }

        /// @brief Remove a child by index
        /// @param index The index of the child
        /// @return true if the child was removed, false if doesn't exist. Will not throw
        /// exception if index is out of range, just returns false.
        bool remove_child(size_t index)
        {
            if (index >= m_children.size())
            {
                return false;
            }

            auto it = std::next(m_children.begin(), index);
            this->m_children_named.erase((*it)->m_name);
            this->m_children.erase(it);

            return true;
        }

        /// @brief Remove children if predicate function returns true
        /// @param func The predicate function to use
        /// @return Number of children removed
        size_t remove_if(std::function<bool(const Node &)> func)
        {
            size_t count = 0;
            std::stack<Node *> node_stack;
            node_stack.push(this); // Start with the current node

            while (!node_stack.empty())
            {
                Node *current = node_stack.top();
                node_stack.pop();

                if (func(*current))
                {
                    this->m_children_named.erase(current->m_name);
                    this->m_children.erase(std::find_if(this->m_children.begin(), this->m_children.end(), [&](const std::shared_ptr<Node> &node)
                                                        { return node->m_name == current->m_name; }));
                    count++;
                }

                for (const auto &child : current->m_children)
                {
                    node_stack.push(child.get()); // Add children to the stack to visit later
                }
            }

            return count;
        }

        /// @brief Remove all children
        void erase_children()
        {
            this->m_children.clear();
            this->m_children_named.clear();
        }

        /// @brief Get a child by name
        /// @param name The unique name of the child
        /// @param child The child
        /// @return true if the child was found, false if doesn't exist
        std::shared_ptr<Node> child(const std::string &name)
        {
            auto it = this->m_children_named.find(name);

            if (it != this->m_children_named.end())
            {
                return it->second;
            }

            return nullptr;
        }

        /// @brief Get a child by index
        /// @param index The index of the child
        /// @param child The child
        /// @return true if the child was found, false if doesn't exist
        std::shared_ptr<Node> child(size_t index)
        {
            if (index >= m_children.size())
            {
                return nullptr;
            }

            auto it = std::next(m_children.begin(), index);

            return it->second;
        }

        /// @brief Check if a child exists by name
        /// @param name The unique name of the child
        /// @return true if the child exists, false if doesn't exist
        bool exists(const std::string &name) const { return this->m_children_named.contains(name); }

        /// @brief Check if a child exists by index
        /// @param index The index of the child
        /// @return true if the child exists, false if doesn't exist
        bool exists(size_t index) const { return index < this->m_children.size(); }

        /// @brief Check if a child exists
        /// @param node The node to search for
        /// @return true if the child exists, false if doesn't exist
        bool exists(const Node &node) const { return this->m_children_named.find(node.m_name) != this->m_children_named.end(); }

        /// @brief Check if node is empty
        /// @return true if empty, false if not empty
        bool is_empty() const { return this->m_children.empty(); }

        /// @brief Count the number of children
        /// @return size_t
        size_t count() const
        {
            size_t count = 0;
            std::stack<const Node *> node_stack;
            node_stack.push(this); // Start with the current node

            while (!node_stack.empty())
            {
                const Node *current = node_stack.top();
                node_stack.pop();
                count++; // Increment count for each node visited

                for (const auto &child : current->m_children)
                {
                    node_stack.push(child.get()); // Add children to the stack to visit later
                }
            }

            return count;
        }

        ///=================================================================
        /// Operators
        ///=================================================================

        /// @brief Check if two nodes are equal
        /// @param other The other node
        /// @return true if equal, false if not equal
        bool operator==(const Node &other) const { return this->m_name == other.m_name; }

        /// @brief Check if node is greater than other node
        /// @param other The other node
        /// @return true if greater, false if not greater
        bool operator>(const Node &other) const { return this->m_name > other.m_name; }

        void operator=(const Node &other)
        {
            size_t index = other.m_name.find("_");
            if (index != std::string::npos)
            {
                this->m_name = other.m_name.substr(0, index) + "_" + std::to_string(std::stoi(other.m_name.substr(index + 1)) + 1);
            }
            else
            {
                this->m_name = other.m_name + "_1";
            }

            this->m_value = other.m_value;
            this->m_children = other.m_children;
            this->m_children_named = other.m_children_named;
        }

        void operator=(const T &value) { this->m_value = value; }

        /// @brief Get a child by name
        /// @param name The unique name of the child
        /// @return Node
        /// @warning Panics if child doesn't exist
        const Node &operator[](const std::string &name) const { return *this->m_children_named.at(name); }

        /// @brief Get a child by name
        /// @param name The unique name of the child
        /// @return Node
        /// @warning Creates child if doesn't exist
        Node &operator[](const std::string &name)
        {
            // create subnodes if they don't exist
            if (!this->m_children_named.contains(name))
            {
                this->add_child(Node<T>(T(), name));
            }

            return *this->m_children_named.at(name);
        }

        /// @brief Get a child by index
        /// @param index The index of the child
        /// @return Node
        /// @warning Panics if child doesn't exist
        const Node &operator[](size_t index) const { return *this->m_children.at(index); }

        /// @brief Get a child by index
        /// @param index The index of the child
        /// @return Node
        /// @warning Panics if child doesn't exist
        Node &operator[](size_t index) { return *this->m_children.at(index); }

        ///=================================================================
        /// Traversal
        ///=================================================================

        /// @brief Depth first search
        /// @param func The predicate function to use
        /// @param node The resulting node
        /// @return true if found, false if not found
        bool find_dfs(std::function<bool(const Node &)> func, Node &node) const
        {
            std::stack<const Node *> node_stack;
            node_stack.push(this); // Start with the current node

            while (!node_stack.empty())
            {
                const Node *current = node_stack.top();
                node_stack.pop();

                if (func(*current))
                {
                    node = *current;
                    return true;
                }

                for (const auto &child : current->m_children)
                {
                    node_stack.push(child.get()); // Add children to the stack to visit later
                }
            }

            return false;
        }

        /// @brief Breadth first search
        /// @param func The predicate function to use
        /// @param node The resulting node
        /// @return true if found, false if not found
        bool find_bfs(std::function<bool(const Node &)> func, Node &node) const
        {
            std::queue<const Node *> node_queue;
            node_queue.push(this); // Start with the current node

            while (!node_queue.empty())
            {
                const Node *current = node_queue.front();
                node_queue.pop();

                if (func(*current))
                {
                    node = *current;
                    return true;
                }

                for (const auto &child : current->m_children)
                {
                    node_queue.push(child.get()); // Add children to the queue to visit later
                }
            }

            return false;
        }

        /// @brief Find shortest path to a node
        /// @param name The name of the node to search for
        /// @param path The resulting path
        /// @return true if found, false if not found
        bool find_path(const std::string &name, std::vector<Node> &path) const
        {
            std::queue<std::pair<const Node *, std::vector<Node>>> node_queue;
            node_queue.push({this, {}}); // Start with the current node and an empty path

            while (!node_queue.empty())
            {
                const Node *current = node_queue.front().first;
                std::vector<Node> current_path = node_queue.front().second;
                node_queue.pop();

                // Update the current path with the current node
                current_path.push_back(*current);

                if (current->m_name == name)
                {
                    path = std::move(current_path); // Assign the found path
                    return true;
                }

                for (const auto &child : current->m_children)
                {
                    if (child)
                    {                                                 // Check if child is not null
                        node_queue.push({child.get(), current_path}); // Add child with updated path
                    }
                }
            }

            return false;
        }

        /// @brief Calculate distance between two nodes
        /// @param node other node
        /// @return size_t
        ssize_t distance(const Node &node) const
        {
            return this->distance(node.m_name);
        }

        /// @brief Calculate distance between two nodes
        /// @param name The name of the other node
        /// @return size_t
        ssize_t distance(const std::string &name) const
        {
            std::vector<Node> path;
            if (!this->find_path(name, path))
            {
                return -1;
            }

            return path.size() - 1;
        }

        /// @brief Get the depth from the current node
        /// @return size_t
        size_t depth() const
        {
            if (m_children.empty())
            {
                return 0; // Base case: If no children, depth is 0
            }
            else
            {
                size_t max_child_depth = 0;
                for (const auto &child : m_children)
                {
                    size_t child_depth = child->depth();
                    max_child_depth = std::max(max_child_depth, child_depth);
                }
                return 1 + max_child_depth; // Add 1 to the maximum child depth to get the depth of the current node
            }
        }

        /// @brief Depth first traversal
        /// @param func The function to call on each node
        size_t traverse_dfs(std::function<void(Node &)> func)
        {
            size_t count = 0;
            std::stack<Node *> node_stack;
            node_stack.push(this); // Start with the current node

            while (!node_stack.empty())
            {
                Node *current = node_stack.top();
                node_stack.pop();
                func(*current);
                count++; // Increment count for each node visited

                for (const auto &child : current->m_children)
                {
                    node_stack.push(child.get()); // Add children to the stack to visit later
                }
            }

            return count;
        }

        /// @brief Breadth first traversal
        /// @param func The function to call on each node
        size_t traverse_bfs(std::function<void(Node &)> func)
        {
            size_t count = 0;
            std::queue<Node *> node_queue;
            node_queue.push(this); // Start with the current node

            while (!node_queue.empty())
            {
                Node *current = node_queue.front();
                node_queue.pop();
                func(*current);
                count++; // Increment count for each node visited

                for (const auto &child : current->m_children)
                {
                    node_queue.push(child.get()); // Add children to the queue to visit later
                }
            }

            return count;
        }

        ///=================================================================
        /// Other
        ///=================================================================

        void invert()
        {
            std::stack<Node *> node_stack;
            node_stack.push(this); // Start with the current node

            while (!node_stack.empty())
            {
                Node *current = node_stack.top();
                node_stack.pop();

                std::reverse(current->m_children.begin(), current->m_children.end());

                for (const auto &child : current->m_children)
                {
                    node_stack.push(child.get()); // Add children to the stack to visit later
                }
            }
        }

        void shuffle(uint64_t seed = 10)
        {
            std::stack<Node *> node_stack;
            std::shuffle(this->m_children.begin(), this->m_children.end(), std::default_random_engine(seed));

            node_stack.push(this); // Start with the current node

            while (!node_stack.empty())
            {
                Node *current = node_stack.top();
                node_stack.pop();

                std::shuffle(current->m_children.begin(), current->m_children.end(), std::default_random_engine(seed));

                for (const auto &child : current->m_children)
                {
                    node_stack.push(child.get()); // Add children to the stack to visit later
                }
            }
        }

        ///=================================================================
        /// String representation
        ///=================================================================

        /// @brief Get a string representation of the node
        /// @return std::string
        std::string to_json() const
        {
            std::string json = "{";

            json += "\"name\":\"" + this->json_escape_string(this->m_name) + "\",";
            json += "\"value\":" + std::to_string(this->m_value) + ",";

            json += "\"children\":[";

            for (const auto &child : this->m_children)
            {
                json += child->to_json() + ",";
            }

            if (json.back() == ',')
            {
                json.pop_back();
            }

            json += "]}";

            return json;
        }

        std::string to_xml() const
        {
            std::string xml = "";

            xml += "<node name=\"" + this->xml_escape_string(this->m_name) + "\" value=\"" + this->xml_escape_string(std::to_string(this->m_value)) + "\">";

            for (const auto &child : this->m_children)
            {
                xml += child->to_xml();
            }

            xml += "</node>";

            return xml;
        }

        std::string to_ansi_string() const
        {
            std::string hr = "";
            bool init = true;

            std::stack<std::pair<const Node *, size_t>> node_stack;
            node_stack.push({this, 1}); // Start with the current node

            while (!node_stack.empty())
            {
                const Node *current = node_stack.top().first;
                size_t current_indent = node_stack.top().second;
                node_stack.pop();

                if (init)
                {
                    hr += "═╗" + current->m_name + "\n";
                    init = false;
                }

                for (size_t i = 0; i < current->m_children.size(); i++)
                {
                    if (i == current->m_children.size() - 1)
                    {
                        hr += std::string(current_indent, ' ') + "╚╗" + current->m_children[i]->m_name + "\n";
                    }
                    else
                    {
                        hr += std::string(current_indent, ' ') + "╟╴" + current->m_children[i]->m_name + "\n";
                    }
                }

                for (const auto &child : current->m_children)
                {
                    node_stack.push({child.get(), current_indent + 1}); // Add children to the stack to visit later
                }
            }

            return hr;
        }

        std::string to_string() const
        {
            std::string hr = "";
            bool init = true;

            std::stack<std::pair<const Node *, size_t>> node_stack;
            node_stack.push({this, 1}); // Start with the current node

            while (!node_stack.empty())
            {
                const Node *current = node_stack.top().first;
                size_t current_indent = node_stack.top().second;
                node_stack.pop();

                if (init)
                {
                    hr += "+- " + current->m_name + "\n";
                    init = false;
                }

                for (size_t i = 0; i < current->m_children.size(); i++)
                {
                    if (i == current->m_children.size() - 1)
                    {
                        hr += std::string(current_indent, ' ') + "+- " + current->m_children[i]->m_name + "\n";
                    }
                    else
                    {
                        hr += std::string(current_indent, ' ') + "|- " + current->m_children[i]->m_name + "\n";
                    }
                }

                for (const auto &child : current->m_children)
                {
                    node_stack.push({child.get(), current_indent + 1}); // Add children to the stack to visit later
                }
            }

            return hr;
        }

        std::string findpath_string(const std::string &name) const
        {
            std::vector<Node> path;
            std::string path_string = "";

            if (this->find_path(name, path))
            {
                for (const auto &node : path)
                {
                    path_string += node.m_name + " -> ";
                }

                if (path_string.size() > 4)
                {
                    path_string.erase(path_string.size() - 4);
                }

                return path_string;
            }

            return "None";
        }

    protected:
        T m_value;
        std::string m_name;
        std::vector<std::shared_ptr<Node>> m_children;
        std::map<std::string, std::shared_ptr<Node>> m_children_named;

        std::string autogenerate_name()
        {
            static int i = 0;
            static std::mutex m;

            std::lock_guard<std::mutex> lock(m);
            std::string n = std::to_string(i++);

            return n == "0" ? "root" : n;
        }

        static std::string json_escape_string(const std::string &input)
        {
            std::string output;
            output.reserve(input.size());
            for (char ch : input)
            {
                switch (ch)
                {
                case '"':
                    output += "\\\"";
                    break;
                case '\\':
                    output += "\\\\";
                    break;
                case '\b':
                    output += "\\b";
                    break;
                case '\f':
                    output += "\\f";
                    break;
                case '\n':
                    output += "\\n";
                    break;
                case '\r':
                    output += "\\r";
                    break;
                case '\t':
                    output += "\\t";
                    break;
                default:
                    if ('\x00' <= ch && ch <= '\x1f')
                    {
                        output += "\\u00";
                        output += "0123456789abcdef"[ch >> 4];
                        output += "0123456789abcdef"[ch & 0xf];
                    }
                    else
                    {
                        output += ch;
                    }
                }
            }
            return output;
        }

        static std::string xml_escape_string(const std::string &input)
        {
            std::string output;
            output.reserve(input.size());
            for (char ch : input)
            {
                switch (ch)
                {
                case '"':
                    output += "&quot;";
                    break;
                case '\'':
                    output += "&apos;";
                    break;
                case '<':
                    output += "&lt;";
                    break;
                case '>':
                    output += "&gt;";
                    break;
                case '&':
                    output += "&amp;";
                    break;
                default:
                    output += ch;
                }
            }
            return output;
        }
    };
} // namespace jcc

namespace std
{
    // overload std::to_string for Node
    template <typename T>
    std::string to_string(const jcc::Node<T> &node)
    {
        return node.to_string();
    }

    // overload <<
    template <typename T>
    std::ostream &operator<<(std::ostream &os, const jcc::Node<T> &node)
    {
        os << node.to_string();
        return os;
    }
}

#endif // _JCC_NODE_HPP_