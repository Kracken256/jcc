#ifndef _JCC_NODE_HPP_
#define _JCC_NODE_HPP_

#include <string>
#include <vector>
#include <memory>
#include <map>
#include <stack>
#include <queue>
#include <mutex>
#include <functional>

namespace jcc
{
    template <typename T>
    class Node
    {
    public:
        ///=================================================================
        /// Constructors & Destructors
        ///=================================================================

        /// @brief Construct a new Node object
        Node()
        {
            this->m_parent = nullptr;
            this->m_name = autogenerate_name();
            this->m_value = T();
            this->m_children = std::vector<std::shared_ptr<Node>>();
            this->m_children_named = std::map<std::string, std::shared_ptr<Node>>();
        }

        /// @brief Construct a new Node object
        /// @param value T of the node
        /// @param name Name must be unique or is automatically generated
        /// @param children Children of the node
        Node(T value, const std::string &name = "", const std::vector<Node> &children = {})
        {
            this->m_parent = nullptr;
            this->m_name = name;
            this->m_value = value;
            this->m_children = std::vector<std::shared_ptr<Node>>();
            this->m_children_named = std::map<std::string, std::shared_ptr<Node>>();
            this->add_children(children);
        }

        /// @brief Destroy the Node object
        ~Node()
        {
            this->m_parent = nullptr;
            this->erase_children();
        }

        ///=================================================================
        /// Getters & Setters
        ///=================================================================

        /// @brief Get the T
        /// @return T
        const T &value() const { return this->m_value; }

        /// @brief Set the T
        /// @param value The value
        void value(const T &value) { this->m_value = value; }

        /// @brief Get the Name
        /// @return std::string
        const std::string &name() const { return this->m_name; }

        /// @brief Set the Name
        /// @param name Name must be unique or is automatically generated
        void name(const std::string &name) { this->m_name = name; }

        /// @brief Get the Children
        /// @return std::vector<Node>
        const std::vector<std::shared_ptr<Node>> &children() const { return this->m_children; }

        /// @brief Get writable Children reference
        /// @return std::vector<Node>
        std::vector<std::shared_ptr<Node>> &children() { return this->m_children; }

        /// @brief Set the Children
        /// @param children The children
        void children(const std::vector<Node> &children) { this->m_children = children; }

        ///=================================================================
        /// Manage children
        ///=================================================================

        /// @brief Add a child
        /// @param child The child to add
        /// @param newname. Unique name of the child. If empty, name is autogenerated
        void add_child(const Node &child, const std::string &newname = "")
        {
            auto us = std::make_shared<Node>(*this);
            auto new_child = std::make_shared<Node>(child);

            if (newname.empty() && child.m_name.empty())
            {
                std::string n = autogenerate_name();
                new_child->m_name = n;
                this->m_children_named[n] = new_child;
            }
            else if (!newname.empty())
            {
                this->m_children_named[newname] = new_child;
            }
            else
            {
                this->m_children_named[child.m_name] = new_child;
            }

            new_child->m_parent = us; // we are the parent
            this->m_children.push_back(new_child);
        }

        /// @brief Add children
        /// @param children The children to add
        void add_children(const std::vector<Node> &children)
        {
            for (const auto &child : children)
            {
                this->add_child(child);
            }
        }

        /// @brief Remove a child by name.
        /// @param name The unique name of the child
        /// @return true if the child was removed. false if doesn't exist
        bool remove_child(const std::string &name)
        {
            auto it = std::find_if(this->m_children.begin(), this->m_children.end(), [&](const std::shared_ptr<Node> &node)
                                   { return node->m_name == name; });

            if (it == this->m_children.end())
            {
                return false;
            }

            (*it)->m_parent = nullptr; // remove parent (us)
            this->m_children_named.erase(name);
            this->m_children.erase(it);

            return true;
        }

        /// @brief Remove a child by index
        /// @param index The index of the child
        /// @return true if the child was removed, false if doesn't exist. Will not throw
        /// exception if index is out of range, just returns false.
        bool remove_child(size_t index)
        {
            if (index >= m_children.size())
            {
                return false;
            }

            auto it = std::next(m_children.begin(), index);
            (*it)->m_parent = nullptr; // remove parent (us)
            this->m_children_named.erase((*it)->m_name);
            this->m_children.erase(it);

            return true;
        }

        /// @brief Remove all children
        void erase_children()
        {
            this->m_children.clear();
            this->m_children_named.clear();
        }

        /// @brief Get a child by name
        /// @param name The unique name of the child
        /// @param child The child
        /// @return true if the child was found, false if doesn't exist
        std::shared_ptr<Node> child(const std::string &name)
        {
            auto it = this->m_children_named.find(name);

            if (it != this->m_children_named.end())
            {
                return it->second;
            }

            return nullptr;
        }

        /// @brief Get a child by index
        /// @param index The index of the child
        /// @param child The child
        /// @return true if the child was found, false if doesn't exist
        std::shared_ptr<Node> child(size_t index)
        {
            if (index >= m_children.size())
            {
                return nullptr;
            }

            auto it = std::next(m_children.begin(), index);

            return it->second;
        }

        /// @brief Check if a child exists by name
        /// @param name The unique name of the child
        /// @return true if the child exists, false if doesn't exist
        bool exists(const std::string &name) const { return this->m_children_named.contains(name); }

        /// @brief Check if a child exists by index
        /// @param index The index of the child
        /// @return true if the child exists, false if doesn't exist
        bool exists(size_t index) const { return index < this->m_children.size(); }

        /// @brief Check if a child exists
        /// @param node The node to search for
        /// @return true if the child exists, false if doesn't exist
        bool exists(const Node &node) const { return this->m_children_named.find(node.m_name) != this->m_children_named.end(); }

        /// @brief Check if a child exists with value
        /// @param value The value of the child
        /// @return true if the child exists, false if doesn't exist
        bool child_with_value(const T &value)
        {
            std::stack<const Node *> node_stack;
            node_stack.push(this); // Start with the current node

            while (!node_stack.empty())
            {
                const Node *current = node_stack.top();
                node_stack.pop();

                if (current->m_value == value)
                {
                    return true;
                }

                for (const auto &child : current->m_children)
                {
                    node_stack.push(child.get()); // Add children to the stack to visit later
                }
            }

            return false;
        }

        /// @brief Get the nodes parent
        /// @return The parent node
        std::shared_ptr<Node> parent() const { return this->m_parent; }

        /// @brief Check if node is empty
        /// @return true if empty, false if not empty
        bool is_empty() const { return this->m_children.empty(); }

        /// @brief Check if node is root
        /// @return true if root, false if not root
        bool is_root() const { return this->m_parent == nullptr; }

        /// @brief Count the number of children
        /// @return size_t
        size_t num_children() const
        {
            size_t count = 0;
            std::stack<const Node *> node_stack;
            node_stack.push(this); // Start with the current node

            while (!node_stack.empty())
            {
                const Node *current = node_stack.top();
                node_stack.pop();
                count++; // Increment count for each node visited

                for (const auto &child : current->m_children)
                {
                    node_stack.push(child.get()); // Add children to the stack to visit later
                }
            }

            return count;
        }

        /// @brief Count the number of children with value
        /// @param value The value of the child
        /// @return size_t
        size_t num_children_with_value(const T &value) const
        {
            size_t count = 0;
            std::stack<const Node *> node_stack;
            node_stack.push(this); // Start with the current node

            while (!node_stack.empty())
            {
                const Node *current = node_stack.top();
                node_stack.pop();

                if (current->m_value == value)
                {
                    count++;
                }

                for (const auto &child : current->m_children)
                {
                    node_stack.push(child.get()); // Add children to the stack to visit later
                }
            }

            return count;
        }

        /// @brief Count the number of children with value (ignores the name)
        /// @param node The node to search for
        /// @return size_t
        size_t num_children(const Node &node) const
        {
            size_t count = 0;
            std::stack<const Node *> node_stack;
            node_stack.push(this); // Start with the current node

            while (!node_stack.empty())
            {
                const Node *current = node_stack.top();
                node_stack.pop();

                if (current->m_value == node.m_value)
                {
                    count++;
                }

                for (const auto &child : current->m_children)
                {
                    node_stack.push(child.get()); // Add children to the stack to visit later
                }
            }

            return count;
        }

        ///=================================================================
        /// Operators
        ///=================================================================

        /// @brief Check if two nodes are equal
        /// @param other The other node
        /// @return true if equal, false if not equal
        bool operator==(const Node &other) const { return this->m_name == other.m_name; }

        /// @brief Check if node is greater than other node
        /// @param other The other node
        /// @return true if greater, false if not greater
        bool operator>(const Node &other) const { return this->m_name > other.m_name; }

        /// @brief Get a child by name
        /// @param name The unique name of the child
        /// @return Node
        /// @warning Panics if child doesn't exist
        const Node &operator[](const std::string &name) const { return *this->m_children_named.at(name); }

        /// @brief Get a child by name
        /// @param name The unique name of the child
        /// @return Node
        /// @warning Panics if child doesn't exist
        Node &operator[](const std::string &name) { return *this->m_children_named.at(name); }

        /// @brief Get a child by index
        /// @param index The index of the child
        /// @return Node
        /// @warning Panics if child doesn't exist
        const Node &operator[](size_t index) const { return *this->m_children.at(index); }

        /// @brief Get a child by index
        /// @param index The index of the child
        /// @return Node
        /// @warning Panics if child doesn't exist
        Node &operator[](size_t index) { return *this->m_children.at(index); }

        ///=================================================================
        /// Traversal
        ///=================================================================

        /// @brief Get the root node
        /// @return Node
        const Node &root() const
        {
            const Node *current = this;
            while (current->m_parent != nullptr)
            {
                current = current->m_parent.get();
            }
            return *current;
        }

        /// @brief Get the root node
        /// @return Node
        Node &root()
        {
            Node *current = this;
            while (current->m_parent != nullptr)
            {
                current = current->m_parent.get();
            }
            return *current;
        }

        /// @brief Depth first search
        /// @param value The value of the node to search for
        /// @param node The resulting node
        /// @return true if found, false if not found
        bool find_dfs(std::function<bool(const Node &)> func, Node &node) const
        {
            std::stack<const Node *> node_stack;
            node_stack.push(this); // Start with the current node

            while (!node_stack.empty())
            {
                const Node *current = node_stack.top();
                node_stack.pop();

                if (func(*current))
                {
                    node = *current;
                    return true;
                }

                for (const auto &child : current->m_children)
                {
                    node_stack.push(child.get()); // Add children to the stack to visit later
                }
            }

            return false;
        }

        /// @brief Breadth first search
        /// @param value The value of the node to search for
        /// @param node The resulting node
        /// @return true if found, false if not found
        bool find_bfs(std::function<bool(const Node &)> func, Node &node) const
        {
            std::queue<const Node *> node_queue;
            node_queue.push(this); // Start with the current node

            while (!node_queue.empty())
            {
                const Node *current = node_queue.front();
                node_queue.pop();

                if (func(*current))
                {
                    node = *current;
                    return true;
                }

                for (const auto &child : current->m_children)
                {
                    node_queue.push(child.get()); // Add children to the queue to visit later
                }
            }

            return false;
        }

        /// @brief Find shortest path to a node
        /// @param name Name of the node to search for
        /// @param path The resulting path
        /// @return true if found, false if not found
        bool find_path(const std::string &name, std::vector<Node> &path) const
        {
            std::queue<std::pair<const Node *, std::vector<Node>>> node_queue;
            node_queue.push({this, {}}); // Start with the current node and an empty path

            while (!node_queue.empty())
            {
                const Node *current = node_queue.front().first;
                std::vector<Node> current_path = node_queue.front().second;
                node_queue.pop();

                // Update the current path with the current node
                current_path.push_back(*current);

                if (current->m_name == name)
                {
                    path = std::move(current_path); // Assign the found path
                    return true;
                }

                for (const auto &child : current->m_children)
                {
                    if (child)
                    {                                                 // Check if child is not null
                        node_queue.push({child.get(), current_path}); // Add child with updated path
                    }
                }
            }

            return false;
        }

        ///=================================================================
        /// String representation
        ///=================================================================

        /// @brief Get a string representation of the node
        /// @return std::string
        std::string to_json() const
        {
            std::string json = "{";

            if (this->m_parent != nullptr)
            {
                json += "\"name\":\"" + this->json_escape_string(this->m_name) + "\",";
                json += "\"value\":\"" + this->json_escape_string(std::to_string(this->m_value)) + "\",";
            }
            else
            {
                json += "\"name\":\"root\",\"value\":\"\",";
            }

            json += "\"children\":[";

            for (const auto &child : this->m_children)
            {
                json += child->to_json() + ",";
            }

            if (json.back() == ',')
            {
                json.pop_back();
            }

            json += "]}";

            return json;
        }

        std::string to_xml() const
        {
            std::string xml = "";

            if (this->m_parent != nullptr)
            {
                xml += "<node name=\"" + this->xml_escape_string(this->m_name) + "\" value=\"" + this->xml_escape_string(std::to_string(this->m_value)) + "\">";
            }
            else
            {
                xml += "<node name=\"root\" value=\"\">";
            }

            for (const auto &child : this->m_children)
            {
                xml += child->to_xml();
            }

            xml += "</node>";

            return xml;
        }

        std::string findpath_string(const std::string &name) const
        {
            std::vector<Node> path;
            std::string path_string = "";

            if (this->find_path(name, path))
            {
                for (const auto &node : path)
                {
                    path_string += node.m_name + " -> ";
                }

                if (path_string.size() > 4)
                {
                    path_string.erase(path_string.size() - 4);
                }
            }

            return path_string;
        }

    protected:
        T m_value;
        std::string m_name;
        std::shared_ptr<Node> m_parent;
        std::vector<std::shared_ptr<Node>> m_children;
        std::map<std::string, std::shared_ptr<Node>> m_children_named;

        std::string autogenerate_name()
        {
            static int i = 0;
            static std::mutex m;

            std::lock_guard<std::mutex> lock(m);
            std::string n = std::to_string(i++);

            return n == "0" ? "root" : n;
        }

        static std::string json_escape_string(const std::string &input)
        {
            std::string output;
            output.reserve(input.size());
            for (char ch : input)
            {
                switch (ch)
                {
                case '"':
                    output += "\\\"";
                    break;
                case '\\':
                    output += "\\\\";
                    break;
                case '\b':
                    output += "\\b";
                    break;
                case '\f':
                    output += "\\f";
                    break;
                case '\n':
                    output += "\\n";
                    break;
                case '\r':
                    output += "\\r";
                    break;
                case '\t':
                    output += "\\t";
                    break;
                default:
                    if ('\x00' <= ch && ch <= '\x1f')
                    {
                        output += "\\u00";
                        output += "0123456789abcdef"[ch >> 4];
                        output += "0123456789abcdef"[ch & 0xf];
                    }
                    else
                    {
                        output += ch;
                    }
                }
            }
            return output;
        }

        static std::string xml_escape_string(const std::string &input)
        {
            std::string output;
            output.reserve(input.size());
            for (char ch : input)
            {
                switch (ch)
                {
                case '"':
                    output += "&quot;";
                    break;
                case '\'':
                    output += "&apos;";
                    break;
                case '<':
                    output += "&lt;";
                    break;
                case '>':
                    output += "&gt;";
                    break;
                case '&':
                    output += "&amp;";
                    break;
                default:
                    output += ch;
                }
            }
            return output;
        }
    };
} // namespace jcc

#endif // _JCC_NODE_HPP_